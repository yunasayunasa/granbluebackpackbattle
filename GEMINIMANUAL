Odyssey Engine v2.1 - Internal Architecture Specification for AI Analysis & Development
Document ID: OE-IAS-2.1-FINAL
Version: 2.1
Classification: GEMINI_INTERNAL_SPEC
Objective: To provide a comprehensive, logically-structured model of the Odyssey Engine's architecture, data flow, and core protocols. This document serves as the ground truth for any future development, debugging, or extension tasks, ensuring architectural integrity.
1.0 Global Architecture & Service Locator
1.1 Global Singleton Pattern:
The engine employs a Service Locator pattern using Phaser.Registry as the central repository for global singleton services. This avoids global namespace pollution and ensures a single point of access for critical managers.
1.2 Core Services & Initialization Locus:
Service	Class	Initialization Locus	Registry Key	Criticality
State Manager	StateManager	PreloadScene.create	stateManager	MAXIMUM
Config Manager	ConfigManager	PreloadScene.create	configManager	High
Sound Manager	SoundManager	SystemScene.create	soundManager	High
1.3 Key Scene Roles & Responsibilities:
PreloadScene: Bootstrapper.
Responsibility: (1) Load critical boot assets (asset_define.json). (2) Instantiate and register StateManager and ConfigManager. (3) Perform a 2-stage asset load based on the asset manifest. (4) Launch SystemScene with initial game data. (5) self.scene.stop().
Lifecycle: Executes once at game boot. MUST be the only scene with active: true in main.js.
SystemScene: Global Mediator & Scene Transition Controller.
Responsibility: (1) Instantiate and register SoundManager. (2) Centralize all scene transitions via an event-driven protocol. (3) Manage global input state (game.input.enabled) during transitions. (4) Manage overlay scenes (NovelOverlayScene, SaveLoadScene) and their input-blocking policies.
Lifecycle: Launched by PreloadScene. Persists for the entire game session. ALL scene transitions MUST be delegated to this scene.
UIScene: Persistent UI Layer & HUD Orchestrator.
Responsibility: (1) Instantiate all HUD components (HpBar, CoinHud, etc.) at create. (2) Subscribe to SystemScene's transition-complete event. (3) Control HUD visibility based on the active game scene (onSceneTransition method). (4) Act as a passive container; it does not know game logic.
Lifecycle: Launched by SystemScene. Persists for the entire game session.
GameScene: Novel-Part Executor & Persistence Layer.
Responsibility: (1) Host the ScenarioManager. (2) Manage novel-specific game objects (characters, backgrounds). (3) Implement performSave/performLoad logic. (4) Communicate its "ready" state to SystemScene via gameScene-load-complete event.
Lifecycle: Run/Stopped by SystemScene. Represents the primary "novel mode" gameplay.
Custom Game Scenes (e.g., BattleScene): Modular Gameplay States.
Responsibility: (1) Implement self-contained game logic. (2) Communicate its "ready" state to SystemScene via scene-ready event. (3) Request return to novel mode via return-to-novel event to SystemScene.
Lifecycle: Run/Stopped by SystemScene.
2.0 State Management Protocol (StateManager.js)
2.1 Core Principle: Single Source of Truth (SSOT). All mutable game state is encapsulated within StateManager.
2.2 Data Schema:
this.f: Game Variables. Persisted within save slots. Represents the mutable state of a single playthrough (flags, stats, etc.).
this.sf: System Variables. Persisted globally in localStorage. Represents meta-game state (config, achievements, global unlocks).
2.3 State Mutation & Event Emission:
setF(key, value): Direct mutation. Emits f-variable-changed only if value changes.
eval(exp): Scripted mutation. This is a critical method.
Creates a shallow copy of this.f (f_before).
Executes exp within a sandboxed new Function('f', 'sf', ...) scope. f and sf are passed by reference, allowing the function to mutate them.
Performs a key-by-key comparison between this.f (post-mutation) and f_before.
For every key where the value has changed, it emits f-variable-changed.
Conclusion: This mechanism allows for complex state changes via a single [eval] tag, while ensuring all dependent systems (like HUDs) are notified of the precise changes.
2.4 State Hydration/Dehydration:
getState(scenarioManager): Serialization. Creates a complete snapshot of the game state for persistence. The returned object schema is the ground truth for save data.
setState(loadedState): Deserialization.
Overwrites this.f and this.sf with data from loadedState.
Crucially, it then iterates through all keys in the new this.f and emits f-variable-changed for each one. This forces all subscribed UI components to refresh their displays to match the loaded state.
3.0 Scene Transition Protocol (Mediated by SystemScene)
3.1 Protocol State Machine:
isProcessingTransition (boolean flag): Acts as a mutex to prevent concurrent transitions.
game.input.enabled (boolean): Global input lock during transitions.
3.2 Transition Flow (GameScene -> BattleScene via [jump]):
handleJump:
Calls GameScene.performSave(0) (auto-save).
Emits request-scene-transition event to SystemScene with payload { to, from, params }.
Calls ScenarioManager.stop() to terminate the novel-part game loop.
SystemScene._handleRequestSceneTransition:
Sets isProcessingTransition = true.
Sets game.input.enabled = false.
Calls this.scene.stop(from_scene).
Calls _startAndMonitorScene(to_scene, params).
SystemScene._startAndMonitorScene:
Retrieves the target scene instance: this.scene.get(sceneKey).
Registers a once listener for the scene's completion event.
GameScene: listens for 'gameScene-load-complete'.
Other Scenes: listen for 'scene-ready'.
Calls this.scene.run(sceneKey, params).
Target Scene (BattleScene.create):
Performs all initialization.
At the very end of create, emits this.events.emit('scene-ready').
SystemScene._onTransitionComplete (Completion event listener callback):
Sets isProcessingTransition = false.
Sets game.input.enabled = true.
Emits transition-complete event for UIScene to consume.
3.3 Return Flow (BattleScene -> GameScene):
BattleScene:
Emits return-to-novel event to SystemScene with payload { from, params }.
SystemScene._handleReturnToNovel:
Protocol is identical to a standard transition, but the target is hardcoded to GameScene, and the returnParams are passed through.
GameScene.init: Receives returnParams.
GameScene.create:
Detects isResuming = true.
Calls await this.performLoad(0, this.returnParams).
GameScene.performLoad:
Loads state from localStorage.
Calls StateManager.setState().
Applies returnParams via StateManager.eval().
Calls await _rebuildScene().
Inside a finally block, emits 'gameScene-load-complete'. This guarantees the signal is sent to SystemScene even if the load process fails, preventing a system-wide freeze.
4.0 Scenario Execution Engine (ScenarioManager.js)
4.1 The Game Loop (gameLoop):
An async while loop that executes as long as no wait-state flag is set (isWaitingClick, isWaitingChoice, isStopped).
Processes one line of the scenario script at a time by calling await this.parse(line).
The await is critical, as tag handlers can be asynchronous (e.g., animations).
4.2 Tag Handler Protocol:
A handler is a function that receives (manager, params).
Asynchronous Handlers (e.g., chara_show with animation): Must return a Promise that resolves when the tag's action is complete. ScenarioManager will await this promise.
Synchronous Handlers (e.g., if): Can be a standard function. await will still work and resolve immediately.
Flow-breaking Handlers (e.g., jump, s): Do not return a Promise. They stop the loop by setting a wait-state flag (isStopped) or by calling manager.stop().
4.3 Dynamic Asset Loading (loadScenario):
Receives a scenarioKey.
Checks if the text is already in cache. If not, dynamically loads it via this.scene.load.
Parses the loaded text for @asset declarations before processing any other lines.
Compares the declared assets against the texture/audio cache.
If any assets are missing, it launches a temporary LoadingScene to load them. The await new Promise construct pauses loadScenario until the loading is complete.
Only after all required assets are confirmed to be present, it replaces the internal scenario context and proceeds with execution.
Implication: This enables large, modular games where assets are loaded on-demand per chapter/scene, minimizing initial load time.
5.0 Development & Extension Protocols
5.1 Adding a New Tag:
Create src/handlers/new_tag.js. Export a handler function handleNewTag.
The function must adhere to the Tag Handler Protocol (see 4.2). It must manipulate the scene via manager.scene or state via manager.stateManager.
In src/handlers/index.js, import the function and add it to the tagHandlers export object: 'new_tag': handleNewTag.
No modification to GameScene or ScenarioManager is required. The system uses dynamic imports to load the handlers.
5.2 Adding a New Game Scene (PuzzleScene):
Create src/scenes/PuzzleScene.js, extending Phaser.Scene.
Adhere to the 5 Commandments for Custom Scenes:
Emit scene-ready: At the end of create(), call this.events.emit('scene-ready');. This is the handshake signal to SystemScene.
Play BGM: In create(), call this.soundManager.playBgm('puzzle_music');. The manager handles stopping the previous track.
Return to Novel: To end the scene, emit an event to SystemScene: this.scene.get('SystemScene').events.emit('return-to-novel', { from: this.scene.key, params: { score: 100 } });. NEVER call this.scene.stop() on yourself.
Implement shutdown(): Clean up all scene-specific timers, event listeners, and objects to prevent memory leaks.
Do Not Touch HUD: Modify game state via this.stateManager.setF('puzzle_pieces', 5);. The UIScene and its components will react automatically.
Add PuzzleScene to the scene list in main.js.
END OF DOCUMENT